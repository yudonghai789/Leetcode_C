>冒泡排序、插入排序、选择排序这三种算法的时间复杂度都为 O(n^2)，只适合小规模的数据

>为什么归并排序就会比插入排序等初级排序算法的复杂度小呢？       
因为归并排序每次都把元素往正确的方向移动？还是有比较“记忆”，前面的比较优化了后面的比较？      
用4个数进行模拟，假如有ABCD 4个数的序列，要进行升序排序。    
对于插入排序，最坏的情况就是A>B>C>D，这样要比较次数为6次，排序过程如下：    
BACD BCAD CBAD CBDA CDBA DCBA    
这种情况下，每个数都要和其他数进行比较。    
而如果用归并排序，最坏的一种情况是A<C<B<D，那么需要比较的有5次：    
A-B, C-D A-C, C-B, B-D    
比插入的少了一次A-D，因为A比C小，所以不需要再跟D进行比较，这就是比较的“记忆”，当然这只是4个数的情况，当数越多，这种记忆的优势会更加明显，最终导致归并排序的复杂度要远远小于插入排序。另外，归并排序过程中数字可以远距离移动，而插入排序（不包括希尔排序）只能逐位进行移动，这也是归并排序更优的另一个原因。    

>两种时间复杂度为 O(nlogn) 的排序算法——归并排序（Merge Sort）和快速排序（Quick Sort），他们都用到了分治思想，非常巧妙    
但实际应用中采用快速排序而不是合并排序？    
1.归并不是原地排序算法(引自前 Google 工程师王争的说法)   
2.《算法图解》说过另一个方面：虽然平均时间复杂度都是 O(logN), 但归并排序的常数部分比快排大，因而速度慢    

冒泡排序  选择排序  插入排序   希尔排序



归并排序   链表二分遍历的后续遍历     
  剑指offer 51  数组中的逆序对    
  leetcode 493. 翻转对    
  leetcode 315. 计算右侧小于当前元素的个数    
  
  leetcode 912. 排序数组    
  leetcode 327. 区间和的个数    
  
插入排序   链表二分遍历的前续遍历     
  leetcode 912. 排序数组   
  leetcode 215. 数组中的第K个最大元    


堆排序   

计数排序   
  leetcode 75 颜色分类   （三个数的计数排序或者三个桶的桶排序）    
桶排序    
  
  
基数排序   
  leetcode 164    





  https://blog.csdn.net/pushup8/article/details/85196465
