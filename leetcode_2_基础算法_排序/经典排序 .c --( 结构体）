/******************************************************************************
* 版权所有 (c) 
* 功能描述   : 经典排序  -- 结构体
* 作    者   : 
* 生成日期   : 
******************************************************************************/
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <uthash.h>
#include <math.h>
#include <assert.h>
// 如需使用华为安全函数，请加上 #include "securec.h"
#include "securec.h"
#include "systemDesgin.h"



/* --------------------------------------------------------------------------------------------------------------------------------------------------- *
 *                  -- 宏定义 --                *
 * ---------------------------------------------------------------------------------------------------------------------------------------------------- */



/* ----------------------------------------------------------------------------------------------------------------------------------------------------- *
 *                -- 数据结构的基本定义-- *
 * ----------------------------------------------------------------------------------------------------------------------------------------------------- */

typedef struct Line {
    int left;
    int right;
} Line;



/* ------------------------------------------------------------------------------------------------------------------------------------------------------------- *
 *                -- 对外函数接口 --                *
 * ------------------------------------------------------------------------------------------------------------------------------------------------------------- */


/* ------------------------------------------------------------------------------------------------------------------------------------------------------------ *
 *                -- 工具小函数 --                *
 * ------------------------------------------------------------------------------------------------------------------------------------------------------------ */


/*
 * 交换数组中两个数据的位置
 */
void Swap(int arr[], int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j]= temp;
}



/*
 * 
 */

/*
 * 
 */


/* ------------------------------------------------------------------------------------------------------------------------------------------------------------ *
 *                -- 排序算法 --                
 * 冒泡排序  选择排序  插入排序  希尔排序  归并排序 快速排序 堆排序 计数排序 桶排序 基数排序
 *    https://www.cnblogs.com/huashanqingzhu/p/12350516.html  
 *    https://www.runoob.com/w3cnote/bubble-sort.html
 * ------------------------------------------------------------------------------------------------------------------------------------------------------------ */



/*****************************************************************************
 * 描  述: 冒泡排序（Bubble Sort）
*****************************************************************************/
void ArrayBubbleSort(Line *points, int pointsSize)
{
    Line temp = { 0, };
    for (int i = 0; i < pointsSize; i++) {
        for (int j = i + 1; j < pointsSize; j++) {
            if (points[j].right < points[i].right) {
                temp.left = points[i].left;
                temp.right = points[i].right;

                points[i].left = points[j].left;
                points[i].right = points[j].right;

                points[j].left = temp.left;
                points[j].right = temp.right;
            }
        }
    }
}

/*****************************************************************************
 * 描  述: 选择排序
*****************************************************************************/



/*****************************************************************************
 * 描  述: 插入排序（Insertion Sort)
*****************************************************************************/
void insertion_sort(Line *points, int pointsSize)
{
    int i, j;
    Line key;
    for (i = 1; i < pointsSize; i++) {
        key.left = points[i].left;
        key.right = points[i].right;
        j = i - 1;
        while ((j >= 0) && (points[j].right > key.right)) {
            points[j + 1].left = points[j].left;
            points[j + 1].right = points[j].right;
            j--;
        }
        points[j + 1].left = key.left;
        points[j + 1].right = key.right;
    }
}



/*****************************************************************************
 * 描  述: 希尔排序（Shell Sort
*****************************************************************************/



/*****************************************************************************
 * 描  述: 归并排序（Merge Sort）
*****************************************************************************/


/*****************************************************************************
 * 描  述: 堆排序（Heap Sort）
*****************************************************************************/

/*****************************************************************************
 * 描  述: 快速排序
*****************************************************************************/
void ArrayQuickSort(Line *points, int pointsSize, int low, int high)
{
    if (low >= high) return;

    // 先取左边作为比较的基数
    Line pivot = { points[low].left, points[low].right};
    int pivotIndex = low;

    int left = low;
    int right  = high;

    while (left < right) {
        while (left < right) {
            if (points[right].right >= pivot.right) {
                // 右指针找到一个比基数要小的数为止
                right--;
            } else {
                points[pivotIndex].left = points[right].left;
                points[pivotIndex].right = points[right].right;
                pivotIndex = right;
                break;
            }
            
        } 
            
        while (left < right) {
            if (points[left].right <= pivot.right) {
                left++;
            } else {
                points[pivotIndex].left = points[left].left;
                points[pivotIndex].right = points[left].right;
                pivotIndex = left;
                break;
            }
            
        }
    }

    if (left == right) {
        points[left].left = pivot.left;
        points[left].right = pivot.right;
    }

    ArrayQuickSort(points, pointsSize, low, left - 1);
    ArrayQuickSort(points, pointsSize, left + 1, high);
}



/*****************************************************************************
 * 描  述: 计数排序（Counting Sort）
*****************************************************************************/





/*****************************************************************************
 * 描  述: 桶排序（Bucket Sort）
*****************************************************************************/


/*****************************************************************************
 * 描  述: 基数排序（Radix Sort）
*****************************************************************************/




int main() {
    Line points_1[4] = {
        {10, 16},
        {2, 8},
        {1, 6},
        {7, 12},
    };
    int pointsSize_1 = sizeof(points_1)/ sizeof(points_1[0]);

    ArrayQuickSort(points_1, pointsSize_1, 0, pointsSize_1 - 1);

    insertion_sort(points_1, pointsSize_1);



    Line points_2[10] = {
        {4289383,51220269},{81692777,96329692},{57747793,81986128},{19885386,69645878},{96516649,186158070},{25202362,75692389},{83368690,85888749},{44897763,112411689},{65180540,105563966},{4089172,7544908}
    };
    int pointsSize_2 = sizeof(points_2)/ sizeof(points_2[0]);
    ArrayQuickSort(points_2, pointsSize_2, 0, pointsSize_2 - 1);


    return 0;
}
