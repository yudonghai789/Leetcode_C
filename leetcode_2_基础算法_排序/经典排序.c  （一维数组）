/******************************************************************************
 * 版权所有 (c)
 * 功能描述   : 经典排序 --数组
 * 作    者   :
 * 生成日期   :
 ******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <uthash.h>
#include <math.h>
#include <assert.h>
// 如需使用华为安全函数，请加上 #include "securec.h"
#include "graph.h"

/* ---------------------------------------------------------------------------------------------------------------------------------------------------
 *                   -- 宏定义 --                *
 * ---------------------------------------------------------------------------------------------------------------------------------------------------*/



/* -----------------------------------------------------------------------------------------------------------------------------------------------------
 *                -- 数据结构的基本定义-- *
 * -----------------------------------------------------------------------------------------------------------------------------------------------------*/



/* -------------------------------------------------------------------------------------------------------------------------------------------------------------
 *                -- 对外函数接口 --                *
 * -------------------------------------------------------------------------------------------------------------------------------------------------------------*/




/* ------------------------------------------------------------------------------------------------------------------------------------------------------------
 *                -- 工具小函数 --                *
 * ------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*
 * 交换数组中两个数据的位置
 */
void Swap(int arr[], int i, int j)
{
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

/*
 *
 */

/*
 *
 */

/* ------------------------------------------------------------------------------------------------------------------------------------------------------------
 * *
 *                -- 排序算法 --
 * 冒泡排序  选择排序  插入排序  希尔排序  归并排序 快速排序 堆排序 计数排序 桶排序 基数排序
 *    https://www.cnblogs.com/huashanqingzhu/p/12350516.html
 *    https://www.runoob.com/w3cnote/bubble-sort.html
 * ------------------------------------------------------------------------------------------------------------------------------------------------------------*/

/*****************************************************************************
 * 描  述: 冒泡排序（Bubble Sort）
 *****************************************************************************/
void bubble_sort(int arr[], int len)
{
    int i, j, temp;
    for (i = 0; i < len - 1; i++) {
        for (j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
/*
 *  冒泡排序（Bubble Sort）  我们可以用一个 flag
 *参数记录新一轮的排序中元素是否做过交换，如果没有，说明前面参与比较过的元素已经是正序，那就没必要再从头比较了
 */
void bubble_sort_quicker(int arr[], int n)
{
    int i, j, flag;
    for (i = 0; i < n - 1; i++) {
        flag = 0;
        for (j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                Swap(arr, j, j + 1);
                flag = 1;
            }
        }
        if (!flag)
            return;
    }
}

/*****************************************************************************
 * 描  述: 选择排序
 *****************************************************************************/
void selection_sort(int arr[], int len)
{
    int i, j;
    for (i = 0; i < len - 1; i++) {
        int min = i;
        for (j = i + 1; j < len; j++) {  // 走訪未排序的元素
            if (arr[j] < arr[min]) {     // 找到目前最小值
                min = j;                 // 紀錄最小值
            }
        }
        Swap(arr, i, j);  // 做交換
    }
}

/*****************************************************************************
 * 描  述: 插入排序（Insertion Sort)
 *****************************************************************************/
void insertion_sort(int arr[], int len)
{
    int i, j, key;
    for (i = 1; i < len; i++) {
        key = arr[i];
        j = i - 1;
        while ((j >= 0) && (arr[j] > key)) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}

/*****************************************************************************
 * 描  述: 希尔排序（Shell Sort
 *****************************************************************************/








/*****************************************************************************
 * 描  述: 归并排序（Merge Sort）
 *****************************************************************************/
void MergeSortRecursive(int arr[], int reg[], int start, int end)
{
    if (start >= end) {
        return;
    }

    int len = end - start;
    int mid = (len >> 1) + start;
    int start1 = start, end1 = mid;
    int start2 = mid + 1, end2 = end;
    MergeSortRecursive(arr, reg, start1, end1);
    MergeSortRecursive(arr, reg, start2, end2);

    int k = start;
    while (start1 <= end1 && start2 <= end2) {
        if (arr[start1] <= arr[start2]) {
            reg[k++] = arr[start1++];
        } else {
            reg[k++] = arr[start2++];
        }
    }

    while (start1 <= end1) {
        reg[k++] = arr[start1++];    // 剩下左边的数组大，右边的已经全部排完序
    }
        
    while (start2 <= end2) {
        reg[k++] = arr[start2++];
    }

    for (k = start; k <= end; k++) {
        arr[k] = reg[k];
    }
}

void MergeSort(int arr[], int len)
{
    int reg[len];
    MergeSortRecursive(arr, reg, 0, len - 1);
}






/*****************************************************************************
 * 描  述: 快速排序
 *****************************************************************************/
/* 选取序列的第一个元素作为基准 */
int select_pivot(int arr[], int low)
{
    return arr[low];
}

void quick_sort(int arr[], int low, int high)
{
    int i, j, pivot;
    if (low >= high)
        return;
    pivot = select_pivot(arr, low);
    i = low;
    j = high;
    while (i != j) {
        while (arr[j] >= pivot && i < j)
            j--;
        while (arr[i] <= pivot && i < j)
            i++;
        if (i < j)
            Swap(arr, i, j);
    }
    arr[low] = arr[i];
    arr[i] = pivot;
    quick_sort(arr, low, i - 1);
    quick_sort(arr, i + 1, high);
}

/*****************************************************************************
 * 描  述: 堆排序（Heap Sort）
 *****************************************************************************/

/*****************************************************************************
 * 描  述: 计数排序（Counting Sort）
 *****************************************************************************/

/*****************************************************************************
 * 描  述: 桶排序（Bucket Sort）
 *****************************************************************************/

/*****************************************************************************
 * 描  述: 基数排序（Radix Sort）
 *****************************************************************************/



 

int main()
{
    int arr[] = {22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70};
    int len = (int)sizeof(arr) / sizeof(*arr);
    // bubble_sort(arr, len);
    MergeSort(arr, len);
    int i;
    for (i = 0; i < len; i++)
        printf("%d ", arr[i]);

    return 0;
}
