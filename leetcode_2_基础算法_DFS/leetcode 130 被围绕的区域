#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <assert.h>

/* 130. 被围绕的区域
 * 二维数组的遍历，深度优先和广度优先都行。 但是广度优先算法需要再提供一个队列
 *



给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
 
示例 1：
输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

示例 2：
输入：board = [["X"]]
输出：[["X"]]

 */


// ---------------------------解法一 开始-------------------------------------------------
#define SEARCHFALG 5


int dfs(int **grid, int i, int j, int row, int col)
{

}


void solve(char** board, int boardSize, int* boardColSize){

}
// ---------------------------解法结束-------------------------------------------------



int main() {
	int gradCharData_1[8][13] = {
		{0,0,1,0,0,0,0,1,0,0,0,0,0},
		{0,0,0,0,0,0,0,1,1,1,0,0,0},
		{0,1,1,0,1,0,0,0,0,0,0,0,0},
		{0,1,0,0,1,1,0,0,1,0,1,0,0},
		{0,1,0,0,1,1,0,0,1,1,1,0,0},
		{0,0,0,0,0,0,0,0,0,0,1,0,0},
		{0,0,0,0,0,0,0,1,1,1,0,0,0},
		{0,0,0,0,0,0,0,1,1,0,0,0,0}
	};
	int row_1 = 8;
	int cloum_1 = 13;
	int *gradRowPointer_1[row_1];
    for (int i = 0; i < row_1; i++) {
		gradRowPointer_1[i] = &gradCharData_1[i][0];
	}
	int result_1 = maxAreaOfIsland(gradRowPointer_1, row_1, &cloum_1);
    assert(result_1 == 6);


	// 整数数组不能这样创建，只能这样创建字符串
	// int *gradRowPointer_2[] = {
	// 	{0,0,1,0,0,0,0,1,0,0,0,0,0},
	// 	{0,0,0,0,0,0,0,1,1,1,0,0,0},
	// 	{0,1,1,0,1,0,0,0,0,0,0,0,0},
	// 	{0,1,0,0,1,1,0,0,1,0,1,0,0},
	// 	{0,1,0,0,1,1,0,0,1,1,1,0,0},
	// 	{0,0,0,0,0,0,0,0,0,0,1,0,0},
	// 	{0,0,0,0,0,0,0,1,1,1,0,0,0},
	// 	{0,0,0,0,0,0,0,1,1,0,0,0,0}
	// };
	// int row_2 = 8;
	// int cloum_2 = 13;
	// int result_2 = maxAreaOfIsland(gradRowPointer_2, row_2, &cloum_2);
    // assert(result_2 == 6);


	return 0;
}
