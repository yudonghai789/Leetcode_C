/******************************************************************************
 * 版权所有 (c)
 * 功能描述   : leetcode 2170. 使数组变成交替数组的最少操作数 https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-alternating/
 * 作    者   :
 * 生成日期   :

 *  
      --- 
 ******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <uthash.h>
#include <math.h>
#include <assert.h>
// 如需使用华为安全函数，请加上 #include "securec.h"
// #include "securec.h"





/*
2170. 使数组变成交替数组的最少操作数
给你一个下标从 0 开始的数组 nums ，该数组由 n 个正整数组成。

如果满足下述条件，则数组 nums 是一个 交替数组 ：

nums[i - 2] == nums[i] ，其中 2 <= i <= n - 1 。
nums[i - 1] != nums[i] ，其中 1 <= i <= n - 1 。
在一步 操作 中，你可以选择下标 i 并将 nums[i] 更改 为 任一 正整数。

返回使数组变成交替数组的 最少操作数 。

 

示例 1：

输入：nums = [3,1,3,2,4,3]
输出：3
解释：
使数组变成交替数组的方法之一是将该数组转换为 [3,1,3,1,3,1] 。
在这种情况下，操作数为 3 。
可以证明，操作数少于 3 的情况下，无法使数组变成交替数组。
示例 2：

输入：nums = [1,2,2,2,2]
输出：2
解释：
使数组变成交替数组的方法之一是将该数组转换为 [1,2,1,2,1].
在这种情况下，操作数为 2 。
注意，数组不能转换成 [2,2,2,2,2] 。因为在这种情况下，nums[0] == nums[1]，不满足交替数组的条件。
 

提示：

1 <= nums.length <= 105
1 <= nums[i] <= 105
*/





// ---------------------------解法 开始-----暴力遍历: -----------------------------------------------------

// ---------------------------解法 结束---------------------------------------------------------------------







// ---------------------------解法 开始-----BFS 递归模板: -----------------------------------------------------

// ---------------------------解法 结束---------------------------------------------------------------------











// ---------------------------解法 开始-----BFS 迭代模板: -----------------------------------------------------

// ---------------------------解法 结束-----------------------------------------------------------------------










// ---------------------------解法 开始-----DFS 递归模板: --------------结果不能重复的问题--------------------------------------

// ---------------------------解法 结束----------------------------------------------------------------------











// ---------------------------解法 开始-----DFS 迭代模板: --------------------------------------------------

// ---------------------------解法 结束----------------------------------------------------------------------











// ---------------------------解法 开始-----动态规划 记忆化搜索: ----memTable一定要注意表达 可以表达唯一结果的递归路径,维度不够时，不同结果的的递归路径被误当做相同的路径，维度太多时，剪枝效果不大------------------

// ---------------------------解法 结束----------------------------------------------------------------------







// ---------------------------解法 开始-----动态规划 按顺序递推-----------------------------------------------------

// ---------------------------解法 结束--------------------------------------------------------------------










// ---------------------------解法 开始-----贪心 -------------------------------------------------------------
#define MAX_INTRT_NUM 100001

typedef struct NumCnt {
    int ArrayNum;
    int cnt[MAX_INTRT_NUM];
    
    struct {
        int val;
        int maxCnt;
    } max;

    struct {
        int val;
        int maxCnt;
    } subMax;
} NumCnt;


int minimumOperations(int* nums, int numsSize)
{
    // special case

    NumCnt one = { 0 } ;
    for (int i = 0; i < numsSize; i = i + 2) {
        one.ArrayNum++;
        one.cnt[nums[i]]++;
        if (one.max.maxCnt < one.cnt[nums[i]]) {
            one.max.maxCnt = one.cnt[nums[i]];
            one.max.val = nums[i];
        }
    }

    NumCnt two = { 0 } ;
    for (int i = 1; i < numsSize; i = i + 2) {
        two.ArrayNum++;
        two.cnt[nums[i]]++;
        if (two.max.maxCnt < two.cnt[nums[i]]) {
            two.max.maxCnt = two.cnt[nums[i]];
            two.max.val = nums[i];
        }
    }


    if (one.max.val != two.max.val) {
        return (one.ArrayNum - one.max.maxCnt + two.ArrayNum - two.max.maxCnt);
    }

    for (int i = 0; i < numsSize; i = i + 2) {
        if ((one.max.val !=  nums[i]) && (one.subMax.maxCnt < one.cnt[nums[i]])) {
            one.subMax.maxCnt = one.cnt[nums[i]];
            one.subMax.val = nums[i];
        }
    }

    for (int i = 1; i < numsSize; i = i + 2) {
        if ((two.max.val !=  nums[i]) && (two.subMax.maxCnt < two.cnt[nums[i]])) {
            two.subMax.maxCnt = two.cnt[nums[i]];
            two.subMax.val = nums[i];
        }
    }

    return fmin(one.ArrayNum - one.max.maxCnt + two.ArrayNum - two.subMax.maxCnt, one.ArrayNum - one.subMax.maxCnt + two.ArrayNum - two.max.maxCnt);
}
// ---------------------------解法 结束-----------------------------------------------------------------------








int main(int argc, const char *argv[])
{


    int nums_1[] = { 4,12,91,17,29,2,32,49,5,30,89,21,91,34,71,22,88,32,36,64,28,69,7,100,35,41,62,91,85,61,4,79,77,52,57,97,41,91,13,34,37,84,10,10,37,93,58,35,81,36,81,6,50,27,68 };
    int numsSize_1 = sizeof(nums_1) / sizeof(nums_1[0]);
    int res_1 = minimumOperations(nums_1, numsSize_1);
    assert(res_1 == 51);


    return 0;
}
