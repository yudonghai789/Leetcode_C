/******************************************************************************
 * 版权所有 (c)
 * 功能描述   : leetcode 45. 跳跃游戏 II https://leetcode-cn.com/problems/jump-game-ii/
 * 作    者   :
 * 生成日期   :

 *  
      --- 
 ******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <uthash.h>
#include <math.h>
#include <assert.h>
// 如需使用华为安全函数，请加上 #include "securec.h"
// #include "securec.h"





/*
45. 跳跃游戏 II
给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 
示例 1:

输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
示例 2:

输入: nums = [2,3,0,1,4]
输出: 2
 

提示:

1 <= nums.length <= 104
0 <= nums[i] <= 1000
*/





// ---------------------------解法 开始-----暴力遍历: -----------------------------------------------------

// ---------------------------解法 结束---------------------------------------------------------------------







// ---------------------------解法 开始-----BFS 递归模板: -----------------------------------------------------

// ---------------------------解法 结束---------------------------------------------------------------------











// ---------------------------解法 开始-----BFS 迭代模板: -----------------------------------------------------

// ---------------------------解法 结束-----------------------------------------------------------------------










// ---------------------------解法 开始-----DFS 递归模板: --------------结果不能重复的问题--------------------------------------

// ---------------------------解法 结束----------------------------------------------------------------------











// ---------------------------解法 开始-----DFS 迭代模板: --------------------------------------------------

// ---------------------------解法 结束----------------------------------------------------------------------











// ---------------------------解法 开始-----动态规划 记忆化搜索: ----memTable一定要注意表达 可以表达唯一结果的递归路径,维度不够时，不同结果的的递归路径被误当做相同的路径，维度太多时，剪枝效果不大------------------

// ---------------------------解法 结束----------------------------------------------------------------------







// ---------------------------解法 开始-----动态规划 按顺序递推-----------------------------------------------------

// ---------------------------解法 结束--------------------------------------------------------------------










// ---------------------------解法 开始-----贪心 -------------------------------------------------------------
int jump(int* nums, int numsSize)
{
    int resStep = 0;
    int max = 0;
    int min = 0;
    while (max < numsSize-  1) {
        resStep++;
        int nextMin = max + 1;
        int thisMax = max;
        for (int position = min; position <= thisMax; position++) {
            max = fmax(max, position + nums[position]);
        }

        min = nextMin;
    }

    return resStep;
}
// ---------------------------解法 结束-----------------------------------------------------------------------








int main(int argc, const char *argv[])
{
    int nums_1[] = { 2,3,1,1,4 };
    int numsSize_1 = sizeof(nums_1) / sizeof(nums_1[0]);
    int res_1 = jump(nums_1, numsSize_1);
    assert(res_1 == 2);


    return 0;
}
