/******************************************************************************
 * 版权所有 (c)
 * 功能描述   : OJ 1809. 【软件认证】最佳升级时间窗. https://oj.rnd.huawei.com/problems/1809/details
 * 作    者   :
 * 生成日期   :

 * 
      --- 
 ******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <uthash.h>
#include <math.h>
#include <limits.h>
#include <assert.h>
// 如需使用华为安全函数，请加上 #include "securec.h"
#include "securec.h"
#include "vos_priorityqueue.h"
#include "vos_list.h"





/*
题目描述
有一套系统需升级，为减小系统升级期间的影响，需根据系统过去一段时间内的每小时平均访问数据，来预测最佳升级时间窗。
现给定长度为168(7*24)的整数数组，表示一个周期(假设从周一00:00到周日24:00)的每小时历史数据，最佳升级时间窗选择规则如下：

时间窗内累计用户访问量必须小于等于给定的容忍值。
时间窗必须是连续的x个小时，最大的x即为最佳升级时间窗，且不超过7*24。
时间窗允许跨周期，例如当前周期的第167小时到下一周期的第166小时，是一个长度为168的时间窗。
请计算最佳升级时间窗，并返回其开始时间和结束时间的数组下标。 如果存在多个最佳升级时间窗时，返回开始时间下标最小的一个。

解答要求
时间限制：1000ms, 内存限制：256MB
输入
第一行为整数 n ，表示给定的升级影响的容忍值，取值范围：[0, 2^31)。
第二行为7*24个整数，表示一个周期（7*24）的每个小时用户访问量，每个值的范围：[0, 2^31)。

输出
两个整数，分别表示所计算出的最佳升级时间窗的开始时间下标(包含)和结束时间下标(包含)，不存在时返回-1 -1。

样例
输入样例 1 复制

6
1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 11 12 12 11 10 9 8 7 6 5 4 3 2 1
输出样例 1

22 25
提示样例 1
存在多个最佳升级时间窗，开始时间下标最小为22，结束时间下标为25，其之间的和为 2 + 1 + 1 + 2 = 6，小于等于容忍值6。因此返回22 25。



输入样例 2 复制

167
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 167 1
输出样例 2

167 165
提示样例 2
当前周期的第168小时（下标为167）到下一周期的第166小时（下标为165），累计值为167，小于等于容忍值167。因此返回167 165。



输入样例 3 复制

200
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
输出样例 3

0 167
提示样例 3
一个周期（168小时）所有值累计为168，小于等于容忍值200，所以最佳升级时间窗的长度为168小时，取开始时间下标最小的（即0开始）。因此返回0 167。


*/




// ---------------------------解法 ---------------------------------------------------------------
#define ARR_LEN (7 * 24)

void SlideWinDow(int n, int arr[ARR_LEN], int *start, int *end)
{
    int tempStart = -1;
    int tempEnd = -1;
    unsigned long long tempSum = 0;
    int tempLen = 0;
    while (tempEnd < ARR_LEN * 2 && tempSum <= n && tempEnd - tempStart <= ARR_LEN) {
        if (tempLen < (unsigned long long)(tempEnd - tempStart)) {
            tempLen = (unsigned long long)(tempEnd - tempStart);
            *start = (tempStart + 1) % ARR_LEN;
            *end = tempEnd % ARR_LEN;
        }
        tempEnd++;
        tempSum += arr[tempEnd % ARR_LEN];

        while (tempSum > n && tempStart <= tempEnd && tempStart <= ARR_LEN) {
            tempStart++;
            tempSum -= arr[tempStart % ARR_LEN];
        }
    }
}

void GetBestWindow(int n, int arr[ARR_LEN], int *start, int *end)
{
    // 在此添加你的代码
    *start = -1;
    *end = -1;

    SlideWinDow(n, arr, start, end);
}

/* 代码仅供参考，注意避免圈复杂度过大 */
int main(void)
{
    int n;
    if (scanf_s("%u\n", &n) != 1) { return -1; }

    static int arr[ARR_LEN];
    for (int i = 0; i < ARR_LEN; i++) {
        if (scanf_s("%u", &arr[i]) != 1) {
            return -1;
        }
    }

    int start, end;
    GetBestWindow(n, arr, &start, &end);
    (void)printf("%d %d", start, end);
    return 0;
}
// ---------------------------解法 结束---------------------------------------------------------------------
